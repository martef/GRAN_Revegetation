---
title: "Water data"
author: "Marte Fandrem"
format: html
editor: visual
---

## Packages needed

```{r Packages needed, include=FALSE, return=FALSE, warning=FALSE}

library(tidyverse)

library(lubridate) #For handling time series data
library(timetk)

library(scales)   # to access breaks/formatting functions

library(gridExtra) # for arranging plots

```

## Uploading the data

```{r Upload datasets, include=FALSE, echo=FALSE}

BSM1 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/BSM_1_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

BSM2 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/BSM_2_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

BSM3 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/BSM_3_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

HM1 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/HM_1_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

HM2 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/HM_2_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

HM3 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/HM_3_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

VSM1 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/VSM_1_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

VSM2 <- readr::read_delim('C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/VSM_2_compensated_ready.csv', 

                                  delim = ';',

                                  col_names = TRUE)

```

```{r Merge datasets, echo=FALSE, include=FALSE, return=FALSE, warning=FALSE}

# Join multiple data.frames

list_df = list(BSM1,BSM2,BSM3, VSM1,VSM2, HM1, HM2,HM3)

wt_all <- list_df %>% reduce(full_join)

```

## Combine the Date and Time into a DateTime column

```{r smaller cleanups, echo=FALSE, return=FALSE, include=FALSE}

#Convert "Date" and "Time" columns to a DateTime object

wt_all$DateTime <- as.POSIXct(paste(wt_all$Date, wt_all$Time), format = "%Y-%m-%d %H:%M:%S") 

#Create columns for day, month and year

wt_all$day <- day(wt_all$Date)

wt_all$month <- month(wt_all$Date)

wt_all$year <- year(wt_all$Date)

#I might actually not needs these, as I discovered the summarise_by_time and all the other ...._by_time functions in the timetk-package

#Remove the last dates in September 2023 from the dataset 

wt_all <- wt_all%>%filter((between(Date, as.Date('2020-06-12'), as.Date('2023-09-01')))) 

# write.csv(wt_all, "C:/Users/martef/DokumenterIntern/GitHub/GRAN_Revegetation/Data/wt_all.csv")

#Clean up the environment a bit. Remove excess dataframes
rm(HM1, HM2, HM3, VSM1,VSM2, BSM1,BSM2, BSM3, list_df)

```

## What I want to accomplish

I need to aggregate the data to show:

\- mean/max/min per day

\- mean/max/min per month

\- mean/max/min through growth season

\- how many days with lower than -20cm through growth season

-   max consecutive days with lower than -20cm through growth season

## Plotting the raw data

```{r echo=FALSE}
plot_HM1_2020 <- wt_all %>%
  filter(Station_ID=="HM1") %>%
  filter(year==2020)%>%
  filter(LEVEL>-1)%>%
ggplot(aes(Date,LEVEL)) +
  geom_step(aes(x = Date, y = LEVEL), 
            direction = 'mid',
            linewidth = 1,
            color = "black") +
  xlab("Date 2020") + ylab("WT (m)")+
  scale_x_date(labels=date_format('%b'), date_breaks = '1 month')

plot_HM1_2021 <- wt_all %>%
  filter(Station_ID=="HM1") %>%
  filter(year==2021)%>%
  filter(LEVEL>-1)%>%
ggplot(aes(Date,LEVEL)) +
  geom_step(aes(x = Date, y = LEVEL), 
            direction = 'mid',
            linewidth = 1,
            color = "black") +
  xlab("Date 2021") + ylab("WT (m)")+
  scale_x_date(labels=date_format('%b'), date_breaks = '1 month')

plot_HM1_2022 <- wt_all %>%
  filter(Station_ID=="HM1") %>%
  filter(year==2022)%>%
  filter(LEVEL>-1)%>%
ggplot(aes(Date,LEVEL)) +
  geom_step(aes(x = Date, y = LEVEL), 
            direction = 'mid',
            linewidth = 1,
            color = "black") +
  xlab("Date 2022")+ ylab("WT (m)")+
  scale_x_date(labels=date_format('%b'), date_breaks = '1 month')

plot_HM1_2023 <- wt_all %>%
  filter(Station_ID=="HM1") %>%
  filter(year==2023)%>%
  filter(LEVEL>-1)%>%
ggplot(aes(Date,LEVEL)) +
  geom_step(aes(x = Date, y = LEVEL), 
            direction = 'mid',
            linewidth = 1,
            color = "black") +
  xlab("Date 2023")+ ylab("WT (m)")+
  scale_x_date(labels=date_format('%b'), date_breaks = '1 month')

grid.arrange(plot_HM1_2020, plot_HM1_2021, plot_HM1_2022, plot_HM1_2023, ncol=1)
```

The data from HM1 seems correct, with varied values throughout the time period and with a 'roof' at about 0cm, although the data from Jan to May 2021 seems incorrect both by being extremely low in the beginning of the year when the ground is frozen and covered by snow and extremely high (0.5m) in March to mid-May. HM1 is set on higher, drier grounds than HM2 and HM3, with shallow(-ish) peat. These values seems implausible.

## Filter data for the growth season (May to October)

I only want to include the data for the growth season. I'm including all of May and all of September for now (except for 2023, where we cut the data to end of August, as we retrieved the water loggers in the beginning of September). Maybe May needs to be shortened to mid, but lets look at the data first. Then we avoid the 'weird' data from the winter periods. I'm not really that interested in the winter time data anyways.

```{r}
season_data <- wt_all %>%     
  filter((year >= 2020 & year < 2023) & (month >= 5 & month <= 9) | (year == 2023) & (month >= 5 & month<9))

#Create julian date column
season_data$jday <- yday(season_data$Date)
season_data$month_name <- format(season_data$Date,"%B")
season_data$month_name <- factor(season_data$month_name, levels = month.name)
# write.csv(season_data, file="../Data/season_data.csv") 
```

Then lets look at the data per station again

```{r echo=FALSE, warning=FALSE}
season_data %>%
 filter(Station_ID=='HM1')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at HM1')
```

The water table at HM1 is mainly up around 0cm, but with some dips down to as much as -30cm.

```{r echo=FALSE, warning=FALSE}
season_data %>%
 filter(Station_ID=='HM2')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at HM2')
```

Not sure about HM2... It seems very little responsive after 2020, maybe also within 2020...

I think this one as well is not functioning and I need to exclude the data. I think I can include 2020.

```{r echo=FALSE}
season_data %>%
 filter(Station_ID=='HM3')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at HM3')
```

HM3 looks very similar to HM1, but slightly higher. This is corresponding with the observations.

Then let's look at the data from BSM:

```{r echo=FALSE}
season_data %>%
 filter(Station_ID=='BSM1')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at BSM1')
```

BSM1 has not been working properly after 2021. It seems quite clear that I need to exclude the data from 2022 and 2023.

```{r echo=FALSE}
season_data %>%
 filter(Station_ID=='BSM2')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at BSM2')
```

```{r echo=FALSE}
season_data %>%
 filter(Station_ID=='BSM3')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at BSM3')
```

Then finally let's look at the data from VSM:

```{r echo=FALSE}
season_data %>%
 filter(Station_ID=='VSM1')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at VSM1')

```

```{r echo=FALSE}
season_data %>%
 filter(Station_ID=='BSM2')%>%
  group_by(year(Date)) %>%
  plot_time_series(DateTime, LEVEL,
                   .facet_scales = "free", .smooth=FALSE, 
                   .interactive = TRUE,
                   .title='Water table (m) at BSM2')
```

Similar plots created by ggplot. I have to use Julian dates to get the plots aligned by year.

```{r echo=FALSE}
# Get unique Station_IDs
unique_stations <- unique(season_data$Station_ID)

# Create a separate figure for each Station_ID
for (station in unique_stations) {
  station_data <- season_data%>%
    filter(Station_ID == station)
  
  station_season_plot <- station_data %>%
    ggplot(aes(x = jday, y = LEVEL, color = factor(month_name))) +
    geom_line(na.rm=TRUE) +
    labs(title = paste("Water Table Levels for Station ID", station),
         x = "Julian Date",
         y = "Mean WT",
         color = "Month") +
    geom_hline(yintercept=-0.2, linetype='dashed', color='blue')+
    theme_minimal() +
    facet_grid(year~.)+
    scale_color_viridis_d() + 
    theme(legend.position = "bottom")
  
  print(station_season_plot)
}
```

```{r echo=FALSE}

 season_plot <- season_data %>%
    ggplot(aes(x = jday, y = LEVEL, color = factor(month_name))) +
    geom_line() +
    labs(title = paste("Water Table Levels for Station ID", station),
         x = "Julian Date",
         y = "Mean WT",
         color = "Month") +
    geom_hline(yintercept=-0.2, linetype='dashed', color='blue')+
  scale_color_viridis_d()+  
  theme_minimal() +
    facet_grid(Station_ID~year, scales="free_y")+
    theme(legend.position = "bottom")
  
  print(season_plot)

```

## Remove the data from the malfunctioning stations

```{r warning=FALSE}
season_data <- season_data %>%
  filter(!(year %in%  c('2022', '2023') & Station_ID=='BSM1')) %>%
  filter (!(year %in% c('2021', '2022', '2023') & Station_ID=='HM2'))

#Update the csv as well
#write.csv(season_data, file="../Data/season_data.csv")                     
```

## Daily mean, max and min water table within growth season

```{r warning=FALSE}
# Calculate daily mean, maximum, and minimum levels

daily_means <- season_data %>%
  group_by(Station_ID, Date) %>%
  mutate(daily_mean = mean(LEVEL), daily_max = max(LEVEL), daily_min= min(LEVEL)) 

daily_means <- daily_means %>%
  select(-c('Time','LEVEL', 'TEMPERATURE', 'DateTime'))

daily_means<- unique(daily_means)

#write.csv(daily_means, file="../Data/daily_means.csv")
daily_means
```

```{r echo=FALSE, include=FALSE}
#Testing the summarise_by_time function
daily_means_2 <- season_data %>%
  group_by(Station_ID) %>%
 summarise_by_time(.date_var=DateTime,
                    .by="day",
                    daily_mean = mean(LEVEL), daily_max = max(LEVEL), daily_min= min(LEVEL))

daily_means_2
```

```{r echo=FALSE, warning=FALSE}
monthly_summary <- season_data %>% 
 group_by(Station_ID)%>%
  summarise_by_time(.date_var=DateTime, 
                    .by="month",
                    monthly_mean = mean(LEVEL), monthly_max = max(LEVEL), monthly_min = min(LEVEL) )

monthly_summary$month <- format(monthly_summary$DateTime, '%B')
monthly_summary$month <- factor(monthly_summary$month, levels = month.name)
monthly_summary$year <- year(monthly_summary$DateTime)
print(monthly_summary)
```


```{r}
monthly_summary%>%
 ggplot() +
  geom_point(aes(x= month, y=monthly_min, color='blue')) +
  geom_point(aes(x=month, y=monthly_mean, color='green'))+
  geom_point(aes(x=month, y=monthly_max, color='red')) +
  labs(x = "Month", y = "Water table", color="Water table levels (min, mean, max)") +
theme_minimal() +
    facet_grid(Station_ID~year, scales="free_y")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
    theme(legend.position = "bottom")
```
This plot isn't perfect, as I don't know how to change the labels for various geom_lines. It should ideally be transformed to a long dataset with all min,max and mean in the same column.


Overall summary for the whole growth season

```{r echo=FALSE}
gs <-season_data%>%
  group_by(Station_ID)%>%
  summarise_by_time(.date_var=DateTime,
                    .by="year", gs_mean = mean(LEVEL), gs_max = max(LEVEL), gs_min = min(LEVEL) )
```


## Days with WT below -0.2m

```{r echo=FALSE}
total_days_below_minus_0.2 <- daily_means %>% 
  filter(daily_mean < -0.2) %>% 
  group_by(Station_ID, year) %>% 
  summarise(total_days = n_distinct(Date))%>%
  ungroup()%>%
 complete(Station_ID, year, fill = list(total_days = 0)) %>%
ungroup()
print(total_days_below_minus_0.2, n = Inf)

# Create a data frame with all combinations of year, month, and Station_ID
all_combinations <- expand.grid(
  year = unique(daily_means$year),
  Station_ID = unique(daily_means$Station_ID)
)

# Join the data frame with all combinations with the calculated data
total_days_below_minus_0.2_complete <- left_join(all_combinations, total_days_below_minus_0.2, by = c("year", "Station_ID"))
total_days_below_minus_0.2_complete$total_days[is.na(total_days_below_minus_0.2_complete$total_days)] <- 0

#This is not perfect, as it creates zeros for years that were not measured. BSM was not measured in 2020.

total_days_below_minus_0.2_complete %>%
   filter(!(Station_ID %in% c("BSM1", "BSM2", "BSM3") & year == 2020))

total_days_below_minus_0.2_complete
```

```{r echo=FALSE}
# Count the days with a daily mean below -0.2 per month and station
days_below_minus_0.2_month <- daily_means %>%
  filter(daily_mean < -0.2) %>%
  group_by(Station_ID, year, month) %>%
  summarise(total_days = n_distinct(Date))%>%
 ungroup()

# Create a data frame with all combinations of year, month, and Station_ID
all_combinations <- expand.grid(
  year = unique(daily_means$year),
  month = unique(daily_means$month),
  Station_ID = unique(daily_means$Station_ID)
)

# Join the data frame with all combinations with the calculated data
days_below_minus_0.2_month_complete <- left_join(all_combinations, days_below_minus_0.2_month, by = c("year", "month", "Station_ID"))
days_below_minus_0.2_month_complete$total_days[is.na(days_below_minus_0.2_month_complete$total_days)] <- 0

#This is not perfect either, as it creates zeros for years that were not measured. BSM was not measured in 2020.

days_below_minus_0.2_month_complete %>%
   filter(!(Station_ID %in% c("BSM1", "BSM2", "BSM3") & year == 2020))
```

```{r echo=FALSE}

ggplot(total_days_below_minus_0.2_complete, aes(x = Station_ID, y = total_days, fill = Station_ID)) +
  geom_bar(position="dodge", stat = "identity") +
  labs(x = "", y = "Total Days", fill='Station') +
  theme_minimal()+
  theme(axis.text.x = element_blank())+
  facet_wrap(~year)

```

```{r}
ggplot(days_below_minus_0.2_month_complete, aes(x = month, y = total_days, fill = Station_ID)) +
  geom_col(position='dodge') +
  labs(x = "Month", y = "Total Days", fill='Station') +
  theme_minimal()+
facet_wrap(~year)

```

## Consecutive days with WT below -0.2m

```{r}

df <- daily_means %>%
  mutate(consecutive_days = daily_mean < -0.2) %>%
  group_by(Station_ID, year) %>%
  mutate(consecutive_days = cumsum(consecutive_days) - cummax((!consecutive_days) * cumsum(consecutive_days))) %>%
  ungroup()

result <- df %>%
  group_by(Station_ID, year) %>%
  summarise(consecutive_days_count = max(consecutive_days)) %>%
  ungroup()

result
```

I now have all the data I need to answer my questions. Now to create variables that I can include with the vegetation data.

I need to create one table with data of growth season max/min/mean, total days \<-0.2 and consecutive days with \<-0.2 from each station each year

```{r}
gs$year <- year(gs$DateTime)
gs2 <- gs %>% select(c('gs_mean', 'gs_max', 'gs_min','Station_ID','year'))

final_variables <- result %>%
  full_join(gs2, by=c('Station_ID','year'))
final_variables <- final_variables %>%
  full_join(total_days_below_minus_0.2_complete, by=c('Station_ID', 'year'))

# write.csv(final_variables, '../Data/WT_variables.csv')
```
